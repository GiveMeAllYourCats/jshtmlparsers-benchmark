/*!
 *
 * Copyright 2017 - acrazing
 *
 * @author acrazing joking.young@gmail.com
 * @since 2017-08-19 00:54:46
 * @version 1.0.0
 * @desc parse.ts
 */
import { __assign, __read, __values } from "tslib";
import { ANY, noNestedTags, selfCloseTags } from './config';
import { tokenize, TokenKind } from './tokenize';
import { SyntaxKind, } from './types';
import { getLineRanges, getPosition } from './utils';
import { walk } from './walk';
var index;
var count;
var tokens;
var tagChain;
var nodes;
var token;
var node;
var buffer;
var lines;
var parseOptions;
function init(input, options) {
    if (input === void 0) {
        count = 0;
        tokens.length = 0;
        buffer = '';
    }
    else {
        tokens = tokenize(input);
        count = tokens.length;
        buffer = input;
    }
    index = 0;
    tagChain = void 0;
    nodes = [];
    token = void 0;
    node = void 0;
    lines = void 0;
    parseOptions = options;
}
function pushNode(_node) {
    if (!tagChain) {
        nodes.push(_node);
    }
    else if (_node.type === SyntaxKind.Tag &&
        _node.name === tagChain.tag.name &&
        noNestedTags[_node.name]) {
        tagChain = tagChain.parent;
        pushNode(_node);
    }
    else if (tagChain.tag.body) {
        tagChain.tag.end = _node.end;
        tagChain.tag.body.push(_node);
    }
}
function pushTagChain(tag) {
    tagChain = { parent: tagChain, tag: tag };
    node = void 0;
}
function createLiteral(start, end, value) {
    if (start === void 0) { start = token.start; }
    if (end === void 0) { end = token.end; }
    if (value === void 0) { value = token.value; }
    return { start: start, end: end, value: value, type: SyntaxKind.Text };
}
function createTag() {
    return {
        start: token.start - 1,
        end: token.end,
        type: SyntaxKind.Tag,
        open: createLiteral(token.start - 1),
        name: token.value,
        rawName: buffer.substring(token.start, token.end),
        attributes: [],
        attributeMap: void 0,
        body: null,
        close: null,
    };
}
function createAttribute() {
    return {
        start: token.start,
        end: token.end,
        name: createLiteral(),
        value: void 0,
    };
}
function createAttributeValue() {
    return {
        start: token.start,
        end: token.end,
        value: token.type === TokenKind.AttrValueNq
            ? token.value
            : token.value.substr(1, token.value.length - 2),
        quote: token.type === TokenKind.AttrValueNq
            ? void 0
            : token.type === TokenKind.AttrValueSq
                ? "'"
                : '"',
    };
}
function appendLiteral(_node) {
    if (_node === void 0) { _node = node; }
    _node.value += token.value;
    _node.end = token.end;
}
function unexpected() {
    if (lines === void 0) {
        lines = getLineRanges(buffer);
    }
    var _a = __read(getPosition(lines, token.start), 2), line = _a[0], column = _a[1];
    throw new Error("Unexpected token \"" + token.value + "(" + token.type + ")\" at [" + line + "," + column + "]" +
        (tagChain
            ? " when parsing tag: " + JSON.stringify(tagChain.tag.name) + "."
            : ''));
}
function buildAttributeMap(tag) {
    var e_1, _a;
    tag.attributeMap = {};
    try {
        for (var _b = __values(tag.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
            var attr = _c.value;
            tag.attributeMap[attr.name.value] = attr;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
function parseOpenTag() {
    var state = 0 /* BeforeAttr */;
    var attr = ANY;
    var tag = createTag();
    pushNode(tag);
    if (tag.name === '' || tag.name === '!' || tag.name === '!--') {
        tag.open.value = '<' + tag.open.value;
        if (index === count) {
            return;
        }
        else {
            token = tokens[++index];
            if (token.type !== TokenKind.OpenTagEnd) {
                node = createLiteral();
                tag.body = [node];
                while (++index < count) {
                    token = tokens[index];
                    if (token.type === TokenKind.OpenTagEnd) {
                        break;
                    }
                    appendLiteral();
                }
            }
            tag.close = createLiteral(token.start, token.end + 1, token.value + ">");
            tag.end = tag.close.end;
        }
        return;
    }
    while (++index < count) {
        token = tokens[index];
        if (token.type === TokenKind.OpenTagEnd) {
            tag.end = tag.open.end = token.end + 1;
            tag.open.value = buffer.substring(tag.open.start, tag.open.end);
            if (token.value === '' && !selfCloseTags[tag.name]) {
                tag.body = [];
                pushTagChain(tag);
            }
            else {
                tag.body = void 0;
            }
            break;
        }
        else if (state === 0 /* BeforeAttr */) {
            if (token.type !== TokenKind.Whitespace) {
                attr = createAttribute();
                state = 1 /* InName */;
                tag.attributes.push(attr);
            }
        }
        else if (state === 1 /* InName */) {
            if (token.type === TokenKind.Whitespace) {
                state = 2 /* AfterName */;
            }
            else if (token.type === TokenKind.AttrValueEq) {
                state = 3 /* AfterEqual */;
            }
            else {
                appendLiteral(attr.name);
            }
        }
        else if (state === 2 /* AfterName */) {
            if (token.type !== TokenKind.Whitespace) {
                if (token.type === TokenKind.AttrValueEq) {
                    state = 3 /* AfterEqual */;
                }
                else {
                    attr = createAttribute();
                    state = 1 /* InName */;
                    tag.attributes.push(attr);
                }
            }
        }
        else if (state === 3 /* AfterEqual */) {
            if (token.type !== TokenKind.Whitespace) {
                attr.value = createAttributeValue();
                if (token.type === TokenKind.AttrValueNq) {
                    state = 4 /* InValue */;
                }
                else {
                    attr.end = attr.value.end;
                    state = 0 /* BeforeAttr */;
                }
            }
        }
        else {
            if (token.type === TokenKind.Whitespace) {
                attr.end = attr.value.end;
                state = 0 /* BeforeAttr */;
            }
            else {
                appendLiteral(attr.value);
            }
        }
    }
}
function parseCloseTag() {
    var _context = tagChain;
    while (true) {
        if (!_context || token.value.startsWith(_context.tag.name)) {
            break;
        }
        _context = _context.parent;
    }
    if (!_context) {
        return;
    }
    _context.tag.close = createLiteral(token.start - 2, token.end + 1, "</" + token.value + ">");
    _context.tag.end = _context.tag.close.end;
    _context = _context.parent;
    tagChain = _context;
}
export function parse(input, options) {
    var _a;
    init(input, __assign({ setAttributeMap: false }, options));
    while (index < count) {
        token = tokens[index];
        switch (token.type) {
            case TokenKind.Literal:
                if (!node) {
                    node = createLiteral();
                    pushNode(node);
                }
                else {
                    appendLiteral(node);
                }
                break;
            case TokenKind.OpenTag:
                node = void 0;
                parseOpenTag();
                break;
            case TokenKind.CloseTag:
                node = void 0;
                parseCloseTag();
                break;
            default:
                unexpected();
                break;
        }
        index++;
    }
    var _nodes = nodes;
    if ((_a = parseOptions) === null || _a === void 0 ? void 0 : _a.setAttributeMap) {
        walk(_nodes, {
            enter: function (node) {
                if (node.type === SyntaxKind.Tag) {
                    buildAttributeMap(node);
                }
            },
        });
    }
    init();
    return _nodes;
}
//# sourceMappingURL=parse.js.map